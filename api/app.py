import datetime
import logging
import os
from datetime import datetime as dt
from datetime import timedelta
from logging.config import dictConfig

import psycopg2
from flask import Flask, jsonify, request
from psycopg2 import sql
from psycopg2.extras import RealDictCursor
from werkzeug.middleware.proxy_fix import ProxyFix

from common import api_settings

from . import config


def create_app(config_object=None):
    """Application factory function."""
    app = Flask(__name__)

    # Configure the application
    configure_app(app, config_object)
    configure_logging(app)

    # Register components
    register_error_handlers(app)
    register_basic_routes(app)
    register_report_routes(app)

    # Apply WSGI middleware
    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

    return app


def configure_logging(app):
    """Configure logging."""
    dictConfig(api_settings.API_LOGGING_CONFIG)
    app.logger = logging.getLogger(__name__)


def configure_app(app, config_object=None):
    """Configure the Flask application."""
    # Load configuration from object if provided
    if config_object:
        app.config.from_object(config_object)

    # Load default configuration
    app.config.from_object("common.api_settings")
    app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "your-secret-key-here")
    app.config["DEBUG"] = os.environ.get("FLASK_DEBUG", False)

    # Security configurations
    app.config.update(
        SESSION_COOKIE_SECURE=True,
        SESSION_COOKIE_HTTPONLY=True,
        SESSION_COOKIE_SAMESITE="Lax",
        PERMANENT_SESSION_LIFETIME=timedelta(minutes=60),
    )


def register_error_handlers(app):
    """Register error handlers."""

    @app.errorhandler(401)
    def unauthorized_error(error):
        return jsonify({"error": "Unauthorized - No API key provided"}), 401

    @app.errorhandler(403)
    def forbidden_error(error):
        return jsonify({"error": "Forbidden - Invalid API key"}), 403

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({"error": "Not found"}), 404

    @app.errorhandler(500)
    def internal_error(error):
        return jsonify({"error": "Internal server error"}), 500


def register_basic_routes(app):
    """Register basic routes."""

    @app.route("/")
    def index():
        return jsonify({"message": "Welcome!"})

    @app.route("/health")
    def health_check():
        try:
            return jsonify({"status": "healthy", "timestamp": dt.now(datetime.UTC).isoformat()}), 200
        except Exception as e:
            return jsonify({"status": "unhealthy", "timestamp": dt.now(datetime.UTC).isoformat(), "error": str(e)}), 500


def register_report_routes(app):
    """Register report routes."""

    @app.route("/report", methods=["GET"])
    def report(report_type="profit"):
        """
        Retrieve the latest report generated by the analyzer.

        Parameters
        ----------
        report_type : str, optional
            Type of report to retrieve (default is 'profit')

        Returns
        -------
        flask.Response
            JSON response containing:
            - status: str
                Success or error status
            - message: str
                Description of the operation result
            - data: list
                Report data if available
            - count: int
                Number of records (only if data exists)
            - timestamp: str
                ISO format UTC timestamp

        Notes
        -----
        Query Parameters:
        - type: Report type (default: profit)
        - date: Specific date in YYYY-MM-DD format
        - hour: Specific hour (0-23)
        """
        try:
            app.logger.info(f"Attempting to connect to database with config: {api_settings.DATABASE_CONFIG}")
            with psycopg2.connect(**api_settings.DATABASE_CONFIG) as conn:
                try:
                    with conn.cursor(cursor_factory=RealDictCursor) as cur:
                        # Get report type parameters
                        report_type = request.args.get("type", report_type)

                        # Validate report type
                        if report_type not in api_settings.ALLOWED_REPORTS.keys():
                            return jsonify({"status": "error", "message": "Invalid report type provided"}), 400

                        report_table_name = api_settings.ALLOWED_REPORTS.get(report_type)

                        # Get date and hour parameters
                        date = request.args.get("date")
                        hour = request.args.get("hour")

                        query, params = build_report_query(report_table_name, date, hour)

                        # Combine all query parts
                        app.logger.debug(f"Query: {query.as_string(conn)=}")

                        # Fetch results
                        cur.execute(query, params)

                        # Convert results to list of dictionaries
                        results = []
                        for row in cur.fetchall():
                            results.append(row)

                        if not results:
                            return (
                                jsonify(
                                    {
                                        "status": "success",
                                        "message": "No results found",
                                        "data": [],
                                        "timestamp": dt.now(datetime.timezone.utc).isoformat(),
                                    }
                                ),
                                200,
                            )

                        return (
                            jsonify(
                                {
                                    "status": "success",
                                    "message": "Report retrieved successfully",
                                    "data": results,
                                    "count": len(results),
                                    "timestamp": dt.now(datetime.timezone.utc).isoformat(),
                                },
                            ),
                            200,
                        )

                except psycopg2.Error as dbe:
                    app.logger.error(f"Database operation error: {dbe}")
                    app.logger.error(f"Connection params: host={api_settings.DATABASE_CONFIG['host']}")
                    app.logger.error(f"port={api_settings.DATABASE_CONFIG['port']}")
                    app.logger.error(f"dbname={api_settings.DATABASE_CONFIG['dbname']}")
                    return (
                        jsonify(
                            {
                                "status": "error",
                                "message": "Database operation failed",
                                "timestamp": dt.now(datetime.timezone.utc).isoformat(),
                            }
                        ),
                        500,
                    )

        except psycopg2.Error as dbe:
            app.logger.error(f"Database connection error: {dbe}")
            return (
                jsonify(
                    {
                        "status": "error",
                        "message": "Database connection error",
                        "timestamp": dt.now(datetime.timezone.utc).isoformat(),
                    }
                ),
                500,
            )


def build_report_query(table_name, date=None, hour=None):
    """Build the SQL query for report retrieval based on parameters."""
    params = []
    base_query = sql.SQL("SELECT DISTINCT * FROM {table_name} WHERE 1=1").format(table_name=sql.Identifier(table_name))

    # Case 1: no date, no hour. Get all rows of the latest report.
    if not date and not hour:
        current_datetime = dt.now()
        current_hour = current_datetime.replace(minute=0, second=0, microsecond=0)
        query = sql.SQL(" ").join([base_query, sql.SQL("AND analyzetime >= %s ORDER BY analyzetime DESC, rate DESC;")])
        params.append(current_hour)

    # Case 2: only date. Get all rows of report analyzed on that date.
    elif date and not hour:
        try:
            parsed_date = dt.strptime(date, "%Y-%m-%d")
            day_end = parsed_date.replace(hour=23, minute=59, second=59, microsecond=999999)
            query = sql.SQL(" ").join([base_query, sql.SQL("AND analyzetime >= %s AND analyzetime < %s ORDER BY analyzetime DESC, rate DESC;")])
            params.extend([parsed_date, day_end])
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD")

    # Case 3: only hour. Get all rows of report analyzed for that hour of current day.
    elif hour and not date:
        try:
            current_datetime = dt.now()
            hour_start = current_datetime.replace(hour=int(hour), minute=0, second=0, microsecond=0)
            hour_end = current_datetime.replace(hour=int(hour), minute=59, second=59, microsecond=999999)
            query = sql.SQL(" ").join([base_query, sql.SQL("AND analyzetime >= %s AND analyzetime < %s ORDER BY analyzetime DESC, rate DESC;")])
            params.extend([hour_start, hour_end])
        except ValueError:
            raise ValueError("Invalid hour format. Use 0 - 23")

    # Case 4: both date and hour. Get all rows of report analyzed at that date and hour.
    else:
        try:
            parsed_date = dt.strptime(date, "%Y-%m-%d")
            start_time = parsed_date.replace(hour=int(hour), minute=0, second=0, microsecond=0)
            end_time = parsed_date.replace(hour=int(hour), minute=59, second=59, microsecond=999999)

            query = sql.SQL(" ").join([query, sql.SQL("AND analyzetime >= %s AND analyzetime < %s ORDER BY analyzetime DESC, rate DESC;")])
            params.extend([start_time, end_time])

        except ValueError:
            raise ValueError("Invalid date or hour format. Use YYYY-MM-DD for date and 0 - 23 for hour.")

    return query, params


if __name__ == "__main__":
    env = os.environ.get("FLASK_ENV", "development")
    if env == "production":
        app = create_app(config.ProductionConfig)
    elif env == "testing":
        app = create_app(config.TestingConfig)
    else:
        app = create_app(config.DevelopmentConfig)
